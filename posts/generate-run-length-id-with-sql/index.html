<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Generate Run-Length ID With SQL | Ha Pham</title><meta name=keywords content="data,analytics,sql,tips,session"><meta name=description content="What is run-length ID?
Sometimes during analysis work, you need to group consecutive sequence of values into different &ldquo;runs&rdquo;, and calculate metrics for each run. For example:


Given a time series recording some entity&rsquo;s state, you want to calculate on average, how long does an entity stay in a particular state.



Or a more specific example: Given a series of event data of several users, you want to group the users&rsquo; events into sessions with a session cut-off threshold of your choice
"><meta name=author content="Ha Pham"><link rel=canonical href=http://hoanghapham.github.io/posts/generate-run-length-id-with-sql/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=http://hoanghapham.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://hoanghapham.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://hoanghapham.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://hoanghapham.github.io/apple-touch-icon.png><link rel=mask-icon href=http://hoanghapham.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://hoanghapham.github.io/posts/generate-run-length-id-with-sql/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://hoanghapham.github.io/posts/generate-run-length-id-with-sql/"><meta property="og:site_name" content="Ha Pham"><meta property="og:title" content="Generate Run-Length ID With SQL"><meta property="og:description" content="What is run-length ID? Sometimes during analysis work, you need to group consecutive sequence of values into different “runs”, and calculate metrics for each run. For example:
Given a time series recording some entity’s state, you want to calculate on average, how long does an entity stay in a particular state. Or a more specific example: Given a series of event data of several users, you want to group the users’ events into sessions with a session cut-off threshold of your choice "><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-07T20:42:18+07:00"><meta property="article:modified_time" content="2022-02-07T20:42:18+07:00"><meta property="article:tag" content="Data"><meta property="article:tag" content="Analytics"><meta property="article:tag" content="Sql"><meta property="article:tag" content="Tips"><meta property="article:tag" content="Session"><meta name=twitter:card content="summary"><meta name=twitter:title content="Generate Run-Length ID With SQL"><meta name=twitter:description content="What is run-length ID?
Sometimes during analysis work, you need to group consecutive sequence of values into different &ldquo;runs&rdquo;, and calculate metrics for each run. For example:


Given a time series recording some entity&rsquo;s state, you want to calculate on average, how long does an entity stay in a particular state.



Or a more specific example: Given a series of event data of several users, you want to group the users&rsquo; events into sessions with a session cut-off threshold of your choice
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://hoanghapham.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Generate Run-Length ID With SQL","item":"http://hoanghapham.github.io/posts/generate-run-length-id-with-sql/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Generate Run-Length ID With SQL","name":"Generate Run-Length ID With SQL","description":"What is run-length ID? Sometimes during analysis work, you need to group consecutive sequence of values into different \u0026ldquo;runs\u0026rdquo;, and calculate metrics for each run. For example:\nGiven a time series recording some entity\u0026rsquo;s state, you want to calculate on average, how long does an entity stay in a particular state. Or a more specific example: Given a series of event data of several users, you want to group the users\u0026rsquo; events into sessions with a session cut-off threshold of your choice ","keywords":["data","analytics","sql","tips","session"],"articleBody":"What is run-length ID? Sometimes during analysis work, you need to group consecutive sequence of values into different “runs”, and calculate metrics for each run. For example:\nGiven a time series recording some entity’s state, you want to calculate on average, how long does an entity stay in a particular state. Or a more specific example: Given a series of event data of several users, you want to group the users’ events into sessions with a session cut-off threshold of your choice This technique is also called sessionization.\nGenerate run-length ID with R If you are an R user, you may have heard of this kind of analysis. This operation is made trivial with the data.table package, since its rleid/rleidv function can directly generate run-length IDs that are incremented when a new run is commenced.\nSince I work most of the time with SQL, sometimes I need to have this kind of behavior in my SQL code. After some experiments, I finally figured out a way to do it. Here’s how:\nFirst, indexing all the rows in the dataset Next, figure out the “points” where the state of your entity changes from one to another by comparing current row and a previous row. ID these “switch points”. Use the switch points’ IDs as the ID of the consecutive runs In this post I will use BigQuery’s Standard SQL to demonstrate how this work, but you can easily implement this in other SQL flavors, as long as your SQL support analytical functions (LEAD, LAG, ROW_NUMBER, FIRST_VALUE, LAST_VALUE…)\nGenerate run-length ID with SQL Example: How long does an object stay in a state? Suppose we have a device with two state (active/inactive) and we periodically record the state of the device at a particular time. We want to calculate how long do they typically stay in a certain state\n1. Index all rows, and get the previous state The first step is to create a column containing the previous state, and a “row index” column. We will use the previous_state field to determine the point where the device switch to a new state, and use the idx field to generate the run-length ID.\nSince we have multiple devices, we have to partition by device_id when using lag() to make sure we do not get the state of a device into data of another device.\nselect * , lag(state, 1) over (partition by device_id order by timestamp) as previous_state , row_number() over (order by timestamp) as idx from test.consecutive_runs order by device_id, timestamp 2. Determine the state switching points Next, we will check for the “switch point”. If an event is a switch point, we will make the idx of that event NULL. This is to prepare for the generation of run-length ID.\nwith base as ( select * , lag(state, 1) over (partition by device_id order by timestamp) as previous_state , row_number() over (order by timestamp) as idx from test.consecutive_runs order by device_id, timestamp ) select * , case when previous_state is null or state != previous_state then idx else null end as switch_points from base As you can see, row 1 (start of the event series), row 3, row 7 and row 11 are marked as the “switch points”.\n3. Filling in the NULLs Next we can use the IDs at these switch points to fill the NULL rows below, up to the next switch point. This forward-filling feature can be achieved by BigQuery’s last_value() function:\nwith base as ( select * , lag(state, 1) over (partition by device_id order by timestamp) as previous_state , row_number() over (order by timestamp) as idx from test.consecutive_runs order by device_id, timestamp ) , switching as ( select * , case when previous_state is null or state != previous_state then idx else null end as switch_points from base ) select * , last_value(switch_points ignore nulls) over (order by timestamp) as run_length_id from switching So that’s how we have our run-length IDs. Now we can check on average how long each run lasts:\n... , aggr as ( select device_id , run_length_id , timestamp_diff(max(timestamp), min(timestamp), second) / 60 as session_duration from run_length_table group by 1, 2 ) select device_id , avg(session_duration) as average_session_duration from aggr group by 1 4. Another way to generate run-length IDs In step 2 and 3 above, we made use of NULLs and BigQuery’s last_value() function to generate the IDs. There is another way to generate these IDs using 1, 0 and a moving sum().\nInstead of marking “switch points” using idx and set the following row values to NULL, we can mark the switch point using value 1, and set the following rows to 0:\nwith base as ( select * , lag(state, 1) over (partition by device_id order by timestamp) as previous_state from test.consecutive_runs order by device_id, timestamp ) select * , case when previous_state is null or state != previous_state then 1 else 0 end as switch_points from base Then, use sum(...) over (partition by ...) to perform a running sum of switch points. Whenever the run hits a 1 value, the ID will be increased by one and will stay the same for the next rows (because the next rows are all 0).\nwith base as ( select * , lag(state, 1) over (partition by device_id order by timestamp) as previous_state from test.consecutive_runs order by device_id, timestamp ) , switching as ( select * , case when previous_state is null or state != previous_state then 1 else 0 end as switch_points from base ) select * , sum(switch_points) over (partition by device_id order by timestamp) as run_length_id from switching Final result: Practical use cases for sessionization This technique can have multiple applications, for example:\nYou have records user traffics on your website, but you are not happy with your tracker’s default session grouping. You may want to generate the sessions with your own logic. Your have a complex web application, and you have a specific workflow that you want users to go through. You may want to group user’s actions into workflows, and check the ratio of finished over unfinished flows. Hope that this simple tutorial can give you ideas to solve these kinds of problem.\n","wordCount":"1028","inLanguage":"en","datePublished":"2022-02-07T20:42:18+07:00","dateModified":"2022-02-07T20:42:18+07:00","author":{"@type":"Person","name":"Ha Pham"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://hoanghapham.github.io/posts/generate-run-length-id-with-sql/"},"publisher":{"@type":"Organization","name":"Ha Pham","logo":{"@type":"ImageObject","url":"http://hoanghapham.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://hoanghapham.github.io/ accesskey=h title="Ha Pham (Alt + H)">Ha Pham</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://hoanghapham.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=http://hoanghapham.github.io/projects title=Portfolio><span>Portfolio</span></a></li><li><a href=http://hoanghapham.github.io/posts title=Blog><span>Blog</span></a></li><li><a href=http://hoanghapham.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://hoanghapham.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://hoanghapham.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Generate Run-Length ID With SQL</h1><div class=post-meta><span title='2022-02-07 20:42:18 +0700 +0700'>February 7, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Ha Pham</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-is-run-length-id aria-label="What is run-length ID?">What is run-length ID?</a></li><li><a href=#generate-run-length-id-with-r aria-label="Generate run-length ID with R">Generate run-length ID with R</a></li><li><a href=#generate-run-length-id-with-sql aria-label="Generate run-length ID with SQL">Generate run-length ID with SQL</a><ul><li><a href=#example-how-long-does-an-object-stay-in-a-state aria-label="Example: How long does an object stay in a state?">Example: How long does an object stay in a state?</a><ul><li><a href=#1-index-all-rows-and-get-the-previous-state aria-label="1. Index all rows, and get the previous state">1. Index all rows, and get the previous state</a></li><li><a href=#2-determine-the-state-switching-points aria-label="2. Determine the state switching points">2. Determine the state switching points</a></li><li><a href=#3-filling-in-the-nulls aria-label="3. Filling in the NULLs">3. Filling in the NULLs</a></li><li><a href=#4-another-way-to-generate-run-length-ids aria-label="4. Another way to generate run-length IDs">4. Another way to generate run-length IDs</a></li></ul></li></ul></li><li><a href=#practical-use-cases-for-sessionization aria-label="Practical use cases for sessionization">Practical use cases for sessionization</a></li></ul></div></details></div><div class=post-content><h1 id=what-is-run-length-id>What is run-length ID?<a hidden class=anchor aria-hidden=true href=#what-is-run-length-id>#</a></h1><p>Sometimes during analysis work, you need to group <strong>consecutive sequence of values</strong> into different &ldquo;runs&rdquo;, and calculate metrics for each run. For example:</p><ul><li><p>Given a time series recording some entity&rsquo;s state, you want to calculate on average, how long does an entity stay in a particular state.
<img loading=lazy src=/generate-run-length-id-with-sql/consecutive_runs.png></p></li><li><p>Or a more specific example: Given a series of event data of several users, you want to group the users&rsquo; events into sessions with a session cut-off threshold of your choice
<img loading=lazy src=/generate-run-length-id-with-sql/user_events.png></p></li></ul><p>This technique is also called <strong>sessionization</strong>.</p><h1 id=generate-run-length-id-with-r>Generate run-length ID with R<a hidden class=anchor aria-hidden=true href=#generate-run-length-id-with-r>#</a></h1><p>If you are an R user, you may have heard of this kind of analysis. This operation is made trivial with the <code>data.table</code> package, since its <code>rleid</code>/<code>rleidv</code> function can directly generate <strong>run-length IDs</strong> that are incremented when a new run is commenced.</p><p><img loading=lazy src=/generate-run-length-id-with-sql/rleidv.png></p><p>Since I work most of the time with SQL, sometimes I need to have this kind of behavior in my SQL code. After some experiments, I finally figured out a way to do it. Here&rsquo;s how:</p><ol><li>First, indexing all the rows in the dataset</li><li>Next, figure out the &ldquo;points&rdquo; where the state of your entity changes from one to another by comparing current row and a previous row. ID these &ldquo;switch points&rdquo;.</li><li>Use the switch points&rsquo; IDs as the ID of the consecutive runs</li></ol><p>In this post I will use BigQuery&rsquo;s Standard SQL to demonstrate how this work, but you can easily implement this in other SQL flavors, as long as your SQL support analytical functions (LEAD, LAG, ROW_NUMBER, FIRST_VALUE, LAST_VALUE&mldr;)</p><h1 id=generate-run-length-id-with-sql>Generate run-length ID with SQL<a hidden class=anchor aria-hidden=true href=#generate-run-length-id-with-sql>#</a></h1><h2 id=example-how-long-does-an-object-stay-in-a-state>Example: How long does an object stay in a state?<a hidden class=anchor aria-hidden=true href=#example-how-long-does-an-object-stay-in-a-state>#</a></h2><p>Suppose we have a device with two state (active/inactive) and we periodically record the state of the device at a particular time. We want to calculate how long do they typically stay in a certain state</p><h3 id=1-index-all-rows-and-get-the-previous-state>1. Index all rows, and get the previous state<a hidden class=anchor aria-hidden=true href=#1-index-all-rows-and-get-the-previous-state>#</a></h3><p>The first step is to create a column containing the previous state, and a &ldquo;row index&rdquo; column. We will use the <code>previous_state</code> field to determine the point where the device switch to a new state, and use the <code>idx</code> field to generate the run-length ID.</p><p>Since we have multiple devices, we have to <code>partition by device_id</code> when using <code>lag()</code> to make sure we do not get the state of a device into data of another device.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>  , lag(<span style=color:#66d9ef>state</span>, <span style=color:#ae81ff>1</span>) over (partition <span style=color:#66d9ef>by</span> device_id <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> <span style=color:#66d9ef>timestamp</span>) <span style=color:#66d9ef>as</span> previous_state
</span></span><span style=display:flex><span>  , row_number() over (<span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> <span style=color:#66d9ef>timestamp</span>) <span style=color:#66d9ef>as</span> idx
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> test.consecutive_runs
</span></span><span style=display:flex><span><span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> device_id, <span style=color:#66d9ef>timestamp</span>
</span></span></code></pre></div><p><img loading=lazy src=/generate-run-length-id-with-sql/ex1-01.png></p><h3 id=2-determine-the-state-switching-points>2. Determine the state switching points<a hidden class=anchor aria-hidden=true href=#2-determine-the-state-switching-points>#</a></h3><p>Next, we will check for the &ldquo;switch point&rdquo;. If an event is a switch point, we will make the <code>idx</code> of that event NULL. This is to prepare for the generation of run-length ID.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>with</span> base <span style=color:#66d9ef>as</span> (
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>    , lag(<span style=color:#66d9ef>state</span>, <span style=color:#ae81ff>1</span>) over (partition <span style=color:#66d9ef>by</span> device_id <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> <span style=color:#66d9ef>timestamp</span>) <span style=color:#66d9ef>as</span> previous_state
</span></span><span style=display:flex><span>    , row_number() over (<span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> <span style=color:#66d9ef>timestamp</span>) <span style=color:#66d9ef>as</span> idx
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>from</span> test.consecutive_runs
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> device_id, <span style=color:#66d9ef>timestamp</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>  , <span style=color:#66d9ef>case</span> 
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>when</span> previous_state <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>null</span> <span style=color:#66d9ef>or</span> <span style=color:#66d9ef>state</span> <span style=color:#f92672>!=</span> previous_state 
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>then</span> idx 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>null</span> <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>as</span> switch_points
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> base
</span></span></code></pre></div><p><img loading=lazy src=/generate-run-length-id-with-sql/ex1-02.png></p><p>As you can see, row 1 (start of the event series), row 3, row 7 and row 11 are marked as the &ldquo;switch points&rdquo;.</p><h3 id=3-filling-in-the-nulls>3. Filling in the NULLs<a hidden class=anchor aria-hidden=true href=#3-filling-in-the-nulls>#</a></h3><p>Next we can use the IDs at these switch points to fill the NULL rows below, up to the next switch point. This forward-filling feature can be achieved by BigQuery&rsquo;s <code>last_value()</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>with</span> base <span style=color:#66d9ef>as</span> (
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>    , lag(<span style=color:#66d9ef>state</span>, <span style=color:#ae81ff>1</span>) over (partition <span style=color:#66d9ef>by</span> device_id <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> <span style=color:#66d9ef>timestamp</span>) <span style=color:#66d9ef>as</span> previous_state
</span></span><span style=display:flex><span>    , row_number() over (<span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> <span style=color:#66d9ef>timestamp</span>) <span style=color:#66d9ef>as</span> idx
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>from</span> test.consecutive_runs
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> device_id, <span style=color:#66d9ef>timestamp</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>, switching <span style=color:#66d9ef>as</span> (
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>    , <span style=color:#66d9ef>case</span> 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>when</span> previous_state <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>null</span> <span style=color:#66d9ef>or</span> <span style=color:#66d9ef>state</span> <span style=color:#f92672>!=</span> previous_state 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>then</span> idx 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>null</span> <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>as</span> switch_points
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>from</span> base
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> 
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>  , last_value(switch_points <span style=color:#66d9ef>ignore</span> nulls) over (<span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> <span style=color:#66d9ef>timestamp</span>) <span style=color:#66d9ef>as</span> run_length_id
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> switching
</span></span></code></pre></div><p><img loading=lazy src=/generate-run-length-id-with-sql/ex1-03.png>
<img loading=lazy src=/generate-run-length-id-with-sql/ex1-04.png></p><p>So that&rsquo;s how we have our run-length IDs. Now we can check on average how long each run lasts:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>, aggr <span style=color:#66d9ef>as</span> (
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>select</span> 
</span></span><span style=display:flex><span>    device_id
</span></span><span style=display:flex><span>    , run_length_id
</span></span><span style=display:flex><span>    , timestamp_diff(<span style=color:#66d9ef>max</span>(<span style=color:#66d9ef>timestamp</span>), <span style=color:#66d9ef>min</span>(<span style=color:#66d9ef>timestamp</span>), <span style=color:#66d9ef>second</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>60</span> <span style=color:#66d9ef>as</span> session_duration
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>from</span> run_length_table
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>group</span> <span style=color:#66d9ef>by</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> 
</span></span><span style=display:flex><span>  device_id
</span></span><span style=display:flex><span>  , <span style=color:#66d9ef>avg</span>(session_duration) <span style=color:#66d9ef>as</span> average_session_duration
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> aggr
</span></span><span style=display:flex><span><span style=color:#66d9ef>group</span> <span style=color:#66d9ef>by</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p><img loading=lazy src=/generate-run-length-id-with-sql/ex1-05.png></p><h3 id=4-another-way-to-generate-run-length-ids>4. Another way to generate run-length IDs<a hidden class=anchor aria-hidden=true href=#4-another-way-to-generate-run-length-ids>#</a></h3><p>In step 2 and 3 above, we made use of NULLs and BigQuery&rsquo;s <code>last_value()</code> function to generate the IDs. There is another way to generate these IDs using 1, 0 and a moving <code>sum()</code>.</p><p>Instead of marking &ldquo;switch points&rdquo; using <code>idx</code> and set the following row values to NULL, we can mark the switch point using value <code>1</code>, and set the following rows to 0:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>with</span> base <span style=color:#66d9ef>as</span> (
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>    , lag(<span style=color:#66d9ef>state</span>, <span style=color:#ae81ff>1</span>) over (partition <span style=color:#66d9ef>by</span> device_id <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> <span style=color:#66d9ef>timestamp</span>) <span style=color:#66d9ef>as</span> previous_state
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>from</span> test.consecutive_runs
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> device_id, <span style=color:#66d9ef>timestamp</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>  , <span style=color:#66d9ef>case</span> 
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>when</span> previous_state <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>null</span> <span style=color:#66d9ef>or</span> <span style=color:#66d9ef>state</span> <span style=color:#f92672>!=</span> previous_state 
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>then</span> <span style=color:#ae81ff>1</span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>as</span> switch_points
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> base
</span></span></code></pre></div><p><img loading=lazy src=/generate-run-length-id-with-sql/ex2-01.png></p><p>Then, use <code>sum(...) over (partition by ...)</code> to perform a running sum of switch points. Whenever the run hits a <code>1</code> value, the ID will be increased by one and will stay the same for the next rows (because the next rows are all <code>0</code>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>with</span> base <span style=color:#66d9ef>as</span> (
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>    , lag(<span style=color:#66d9ef>state</span>, <span style=color:#ae81ff>1</span>) over (partition <span style=color:#66d9ef>by</span> device_id <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> <span style=color:#66d9ef>timestamp</span>) <span style=color:#66d9ef>as</span> previous_state
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>from</span> test.consecutive_runs
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> device_id, <span style=color:#66d9ef>timestamp</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>, switching <span style=color:#66d9ef>as</span> (
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>    , <span style=color:#66d9ef>case</span> 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>when</span> previous_state <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>null</span> <span style=color:#66d9ef>or</span> <span style=color:#66d9ef>state</span> <span style=color:#f92672>!=</span> previous_state 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>then</span> <span style=color:#ae81ff>1</span> 
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>as</span> switch_points
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>from</span> base
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>  , <span style=color:#66d9ef>sum</span>(switch_points) over (partition <span style=color:#66d9ef>by</span> device_id <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> <span style=color:#66d9ef>timestamp</span>) <span style=color:#66d9ef>as</span> run_length_id
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> switching
</span></span></code></pre></div><p>Final result:
<img loading=lazy src=/generate-run-length-id-with-sql/ex2-02.png></p><h1 id=practical-use-cases-for-sessionization>Practical use cases for sessionization<a hidden class=anchor aria-hidden=true href=#practical-use-cases-for-sessionization>#</a></h1><p>This technique can have multiple applications, for example:</p><ul><li>You have records user traffics on your website, but you are not happy with your tracker&rsquo;s default session grouping. You may want to generate the sessions with your own logic.</li><li>Your have a complex web application, and you have a specific workflow that you want users to go through. You may want to group user&rsquo;s actions into workflows, and check the ratio of finished over unfinished flows.</li></ul><p>Hope that this simple tutorial can give you ideas to solve these kinds of problem.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://hoanghapham.github.io/tags/data/>Data</a></li><li><a href=http://hoanghapham.github.io/tags/analytics/>Analytics</a></li><li><a href=http://hoanghapham.github.io/tags/sql/>Sql</a></li><li><a href=http://hoanghapham.github.io/tags/tips/>Tips</a></li><li><a href=http://hoanghapham.github.io/tags/session/>Session</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://hoanghapham.github.io/>Ha Pham</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>